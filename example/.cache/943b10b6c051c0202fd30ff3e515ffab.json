{"id":"shader.frag","dependencies":[],"generated":{"js":"module.exports = `precision highp float;\n\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#define GLSLIFY 1\n#endif\n\nfloat aastep(float threshold, float value) {\n  #ifdef GL_OES_standard_derivatives\n    float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n  #else\n    return step(threshold, value);\n  #endif  \n}\n\nvarying vec2 vUv;\n\nuniform vec2 resolution;\nuniform float time;\n\n// You can edit these values to see your changes without a page refresh\nconst float size = 0.3;\nconst vec3 boxColor = vec3(0.950, 0.982, 0.470);\nconst vec3 bgColor = vec3(0.159, 0.164, 0.215);\nconst float speed = 5.9;\n\nvec2 rotate(vec2 v, float a) {\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  return m * v;\n}\n\nfloat getAngle(float time) {\n  return sin(time * speed) * 0.8 + time * 1.3;\n}\n\nvoid main () {\n\n  vec2 box = vUv.xy - 0.5;\n  if (resolution.y >= resolution.x) {\n    box.y *= resolution.y / resolution.x;\n  } else {\n    box.x *= resolution.x / resolution.y;\n  }\n\n  float ang = getAngle(time);\n  ang += box.y * (ang - getAngle(time - 0.01)) * 10.;\n  box = rotate(box, ang);\n  box += 0.5;\n\n  float s = 0.5 - size * 0.5;\n  float inBox = aastep(s, box.x)\n    * aastep(s, box.y)\n    * aastep(s, 1.0 - box.x)\n    * aastep(s, 1.0 - box.y);\n\n  vec3 color = mix(bgColor, boxColor, inBox);\n\n  gl_FragColor = vec4(color, 1.0);\n}`"},"hash":"986b526b4920c4f9c49dfee3557abbc2","cacheData":{}}